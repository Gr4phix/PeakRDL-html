// ============================================================================
//
// Program  : sata_ahci_example.rdl
// Language : Register Description Language (RDL)
// Purpose  : This is a generic example designed to show a number of the
//            RDL Language Features...
//
// ============================================================================

//  Revision:    $Revision:$
//  Date:        $Date:$
//
//  Copyright (c) 2009 The SPIRIT Consortium.
//
//  This work forms part of a deliverable of The SPIRIT Consortium.
//
//  Use of these materials are governed by the legal terms and conditions
//  outlined in the disclaimer available from www.spiritconsortium.org.
//
//  This source file is provided on an AS IS basis.  The SPIRIT
//  Consortium disclaims any warranty express or implied including
//  any warranty of merchantability and fitness for use for a
//  particular purpose.
//
//  The user of the source file shall indemnify and hold The SPIRIT
//  Consortium and its members harmless from any damages or liability.
//  Users are requested to provide feedback to The SPIRIT Consortium
//  using either mailto:feedback@lists.spiritconsortium.org or the forms at
//  http://www.spiritconsortium.org/about/contact_us/
//
//  This file may be copied, and distributed, with or without
//  modifications; this notice must be included on any copy.
//

<% $NUM_SATA_PORTS = 5; %>

// Enums have to be defined before being used!
//
enum ISS_ENUM {
  RESERVED = 4'd0  { desc = "Currently Reserved"; };
  GEN_1    = 4'd1  { desc = "1.5 Gbps Link Speed Only!"; };
  GEN_2    = 4'd2  { desc = "1.5 Gbps and 3.0 Gbps Support"; };
};                                                                   // End of enum: Inteface_Speed_Support


//============================================================================
//
// SATA AHCI General Purpose Registers
// These are not replicated per Port
//
//============================================================================

reg HBA_CAP_REG {
    name = "CAP - HBA Capabilities";
    desc = "This register indicates basic capabilities of the HBA to driver software.";

    default hw=na;
    default sw=r;

    field {
        name = "Number of Ports";
        desc = "0's based value indicating the maximum number of ports
        supported by the HBA silicon. A maximum of 32 ports can be supported. A value of
        '0h', indicating one port, is the minimum requirement.

        Note that the number of ports indicated in this field may be more
        than the number of ports indicated in the GHC.PI register.";
    } NP[5] = 5'b0_00_01;

    field {
        name = "Supports External SATA";
        desc = "When set to '1', indicates that the HBA has one or
        more Serial ATA ports that has a signal only connector that is externally accessible.
        
        If this bit is set to '1', software may refer to the PxCMD.ESP bit to determine whether a
        specific port has its signal connector externally accessible as a signal only connector
        (i.e. power is not part of that connector).
        
        When the bit is cleared to '0', indicates that
        the HBA has no Serial ATA ports that have a signal only connector externally
        accessible.";
    } SXS = 1'b1;

    field {
        name="Enclosure Management Supported";
        desc="When set to '1', indicates that the HBA
        supports enclosure management as defined in section 12.
        When enclosure management is supported, the HBA has implemented the EM_LOC and EM_CTL
        global HBA registers.
        
        When cleared to '0', indicates that the HBA does not support
        enclosure management and the EM_LOC and EM_CTL global HBA registers are not
        implemented.";
    } EMS = 0;

    field {
        name="Command Completion Coalescing Supported";
        desc="When set to '1', indicates
        that the HBA supports command completion coalescing as defined in section 11. When
        command completion coalescing is supported, the HBA has implemented the
        CCC_CTL and the CCC_PORTS global HBA registers.
        
        When cleared to '0', indicates
        that the HBA does not support command completion coalescing and the CCC_CTL and
        CCC_PORTS global HBA registers are not implemented.";
    } CCCS = 1'b1;

    field {
        name="Number of Command Slots";
        desc="0's based value indicating the number of
        command slots per port supported by this HBA. A minimum of 1 and maximum of 32
        slots per port can be supported. The same number of command slots is available on
        each implemented port.";
    } NCS[5]  = 5'h1f;


    field {
        name="Partial State Capable";
        desc="Indicates whether the HBA can support transitions to the
        Partial state.
        
        When cleared to '0', software must not allow the HBA to initiate transitions
        to the Partial state via aggressive link power management nor the PxCMD.ICC field in
        each port, and the PxSCTL.IPM field in each port must be programmed to disallow
        device initiated Partial requests.
        
        When set to '1', HBA and device initiated Partial
        requests can be supported.";
    } PSC = 1'b1;

    field {
        name="Slumber State Capable";
        desc="Indicates whether the HBA can support transitions to
        the Slumber state.
        
        When cleared to '0', software must not allow the HBA to initiate
        transitions to the Slumber state via aggressive link power management nor the
        PxCMD.ICC field in each port, and the PxSCTL.IPM field in each port must be
        programmed to disallow device initiated Slumber requests.
        
        When set to '1', HBA and
        device initiated Slumber requests can be supported.";
    } SSC = 1'b1;

    field {
        name="PIO Multiple DRQ Block";
        desc="If set to '1', the HBA supports multiple DRQ block
        data transfers for the PIO command protocol.
        
        If cleared to '0' the HBA only supports
        single DRQ block data transfers for the PIO command protocol.";
    } PMD = 1'b1;

    field {
        name="FIS-based Switching Supported";
        desc="When set to '1', indicates that the HBA
        supports Port Multiplier FIS-based switching.
        
        When cleared to '0', indicates that the
        HBA does not support FIS-based switching. AHCI 1.0 and 1.1 HBAs shall have this bit
        cleared to '0'.";
    } FBSS = 0;

    field {
        name="Supports Port Multiplier";
        desc="Indicates whether the HBA can support a Port
        Multiplier. When set, a Port Multiplier using command-based switching is supported.
        When cleared to '0', a Port Multiplier is not supported, and a Port Multiplier may not be
        attached to this HBA.";

    } SPM = 0;

    field {
        name="Supports AHCI mode only";
        desc="The SATA controller may optionally support AHCI
        access mechanisms only.
        
        A value of '0' indicates that in addition to the native AHCI
        mechanism (via ABAR), the SATA controller implements a legacy, task-file based
        register interface such as SFF-8038i.
        
        A value of '1' indicates that the SATA controller
        does not implement a legacy, task-file based register interface.";
    } SAM = 1'b1;

    field {
        name="Supports Non-Zero DMA Offsets";
        desc="When set to '1', indicates that the HBA
        can support non-zero DMA offsets for DMA Setup FISes. This bit is reserved for future
        AHCI enhancements. AHCI 1.0 and 1.1 HBAs shall have this bit cleared to '0'";
    } SNZO = 0;


    field {
        name="Interface Speed Support";
        desc="Indicates the maximum speed the HBA can support
        on its ports. These encodings match the system software programmable
        PxSCTL.DET.SPD field.";

        encode = ISS_ENUM;
    } ISS[4] = 4'b0011;

    field {
        name="Supports Command List Override";
        desc="When set to '1', the HBA supports the
        PxCMD.CLO bit and its associated function.
        
        When cleared to '0', the HBA is not
        capable of clearing the BSY and DRQ bits in the Status register in order to issue a
        software reset if these bits are still set from a previous operation.";
    } SCLO = 1'b1;

    field {
        name="Supports Activity LED";
        desc="When set to '1', the HBA supports a single activity
        indication output pin. This pin can be connected to an LED on the platform to indicate
        device activity on any drive.
        
        When cleared to '0', this function is not supported. See
        section 10.10 for more information.";
    } SAL = 0 ;

    field {
        name="Supports Aggressive Link Power Management";
        desc="When set to '1', the HBA
        can support auto-generating link requests to the Partial or Slumber states when there
        are no commands to process.
        
        When cleared to '0', this function is not supported and
        software shall treat the PxCMD.ALPE and PxCMD.ASP bits as reserved. Refer to
        section 8.3.1.3.";
    } SALP = 1'b1;

    field {
        name="Supports Staggered Spin-up";
        desc="When set to '1', the HBA supports staggered
        spin-up on its ports, for use in balancing power spikes.
        
        When cleared to '0', this
        function is not supported. This value is loaded by the BIOS prior to OS initialization.";
    } SSS = 0;

    field {
        name="Supports Mechanical Presence Switch";
        desc="When set to '1', the HBA supports
        mechanical presence switches on its ports for use in hot plug operations.
        
        When cleared to '0', this function is not supported. This value is loaded by the BIOS prior to
        OS initialization.";
    } SMPS = 0;

    field {
        name="Supports SNotification Register";
        desc="When set to '1', the
        HBA supports the PxSNTF (SNotification) register and its associated functionality.
        
        When cleared to '0', the HBA does not support the PxSNTF (SNotification) register and
        its associated functionality. Refer to section 10.10.1.";
    } SSNTF = 1'b1;

    field {
        name="Supports Native Command Queuing";
        desc="Indicates whether the HBA supports
        Serial ATA native command queuing. If set to '1', an HBA shall handle DMA Setup
        FISes natively, and shall handle the auto-activate optimization through that FIS.
        
        If cleared to '0', native command queuing is not supported and software should not issue
        any native command queuing commands.";
    } SNCQ = 1'b1;

    field {
        name="Supports 64-bit Addressing";
        desc="Indicates whether the HBA can access 64-bit
        data structures.
        
        When set to '1', the HBA shall make the 32-bit upper bits of the port
        DMA Descriptor, the PRD Base, and each PRD entry read/write.
        
        When cleared to '0',
        these are read-only and treated as '0' by the HBA.";
    } S64A = 0;
};

reg GHC_REG {
    desc = "This register controls various global actions of the HBA.";

    field {
        woset;                                                           // Write 1 to Set
        name="HBA Reset";
        desc="When set by SW, this bit causes an internal reset of the HBA. All
        state machines that relate to data transfers and queuing shall return to an idle
        condition, and all ports shall be re-initialized via COMRESET (if staggered spin-up is
        not supported).
        
        If staggered spin-up is supported, then it is the responsibility of
        software to spin-up each port after the reset has completed.
        When the HBA has performed the reset action, it shall reset this bit to '0'.
        
        A software write of '0' shall have no effect.
        For a description on which bits are reset when this bit is set, see section 10.4.3.";
    } HR = 0 ;

    field {
        name="Interrupt Enable";
        desc="This global bit enables interrupts from the HBA. When cleared
        (reset default), all interrupt sources from all ports are disabled. When set, interrupts are
        enabled.";
    } IE = 0;

    field {
        sw = r;
        name="MSI Revert to Single Message";
        desc="When set to '1' by hardware, indicates that
        the HBA requested more than one MSI vector but has reverted to using the first vector
        only.
        
        When this bit is cleared to '0', the HBA has not reverted to single MSI mode (i.e.
        hardware is already in single MSI mode, software has allocated the number of
        messages requested, or hardware is sharing interrupt vectors if MC.MME < MC.MMC).
        The HBA may revert to single MSI mode when the number of vectors allocated by the
        host is less than the number requested.
        
        This bit shall only be set to '1' when the following conditions hold:
        
        * MC.MSIE = '1' (MSI is enabled)
        * MC.MMC > 0 (multiple messages requested)
        * MC.MME > 0 (more than one message allocated)
        * MC.MME != MC.MMC (messages allocated not equal to number requested)
        
        When this bit is set to '1', single MSI mode operation is in use and software is
        responsible for clearing bits in the IS register to clear interrupts.
        This bit shall be cleared to '0' by hardware when any of the four conditions stated is
        false. This bit is also cleared to '0' when MC.MSIE = '1' and MC.MME = 0h. In this
        case, the hardware has been programmed to use single MSI mode, and is not
        reverting to that mode.";
    } MRSM = 0 ;

    field {
        hw=na;
        sw=r;
        name="AHCI Enable";
        desc="When set, indicates that communication to the HBA shall be via
        AHCI mechanisms. This can be used by an HBA that supports both legacy
        mechanisms (such as SFF-8038i) and AHCI to know when the HBA is running under an
        AHCI driver.
        
        When set, software shall only communicate with the HBA using AHCI. When cleared,
        software shall only communicate with the HBA using legacy mechanisms. When
        cleared FISes are not posted to memory and no commands are sent via AHCI
        mechanisms.
        
        Software shall set this bit to '1' before accessing other AHCI registers.
        The implementation of this bit is dependent upon the value of the CAP.SAM bit. If
        CAP.SAM is '0', then GHC.AE shall be read-write and shall have a reset value of '0'. If
        CAP.SAM is '1', then AE shall be read-only and shall have a reset value of '1'.";
    } AE[31:31] = 1'b1;
};

reg IS_REG {
    desc = "This register indicates which of the ports within the controller have an interrupt pending and require
    service.";

    field {
        intr;
        stickybit;

        name="Interrupt Pending Status";
        desc="If set, indicates that the corresponding port has an
        interrupt pending. Software can use this information to determine which ports require
        service after an interrupt.
        The IPS[x] bit is only defined for ports that are implemented or for the command
        completion coalescing interrupt defined by CCC_CTL.INT. All other bits are reserved.";
    } IPS[<%=$NUM_SATA_PORTS%>] = <%=$NUM_SATA_PORTS%>'b1;

};

reg PI_REG {
    desc = "This register indicates which ports are exposed by the HBA. It is loaded by the BIOS. It indicates which
    ports that the HBA supports are available for software to use. For example, on an HBA that supports 6
    ports as indicated in CAP.NP, only ports 1 and 3 could be available, with ports 0, 2, 4, and 5 being
    unavailable.
    Software must not read or write to registers within unavailable ports.
    The intent of this register is to allow system vendors to build platforms that support less than the full
    number of ports implemented on the HBA silicon.";

    field {
        hw=rw;
        sw=r;
        name="Port Implemented";
        desc="This register is bit significant. If a bit is set to '1', the
        corresponding port is available for software to use. If a bit is cleared to '0', the port is
        not available for software to use.
        
        The maximum number of bits set to '1' shall not
        exceed CAP.NP + 1, although the number of bits set in this register may be fewer than
        CAP.NP + 1. At least one bit shall be set to '1'.";
    } PI[<%=$NUM_SATA_PORTS%>] = <%=$NUM_SATA_PORTS%>'b1;
};

reg VS_REG {
    default hw=na;
    default sw=r;
    desc="This register indicates the major and minor version of the AHCI specification that the HBA implementation
    supports.
    
    The upper two bytes represent the major version number, and the lower two bytes represent
    the minor version number.
    
    **Example:** Version 3.12 would be represented as 00030102h. Three versions
    of the specification are valid: 0.95, 1.0, and 1.1.";

    field {
        name="Minor Version Number";
    } MNR[16] = 16'h0100;

    field {
        name="Major Version Number";
    } MJR[16] = 16'b1;

};

reg CCC_CTL_REG {
    name = "Command Completion Coalescing Control";
    desc = "
    The command completion coalescing control register is used to configure the command completion
    coalescing feature for the entire HBA.
    
    **Implementation Note:** HBA state variables (examples include hCccComplete and hCccTimer) are used
    to describe the required externally visible behavior. Implementations are not required to have internal
    state values that directly correspond to these variables.";

    field {
        name="Enable";
        desc="When cleared to '0', the command completion coalescing feature is
        disabled and no CCC interrupts are generated. When set to '1', the command
        completion coalescing feature is enabled and CCC interrupts may be generated based
        on timeout or command completion conditions. Software shall only change the contents
        of the TV and CC fields when EN is cleared to '0'. On transition of this bit from '0' to '1',
        any updated values for the TV and CC fields shall take effect.";
    } EN = 0;

    field {
        name="Interrupt";
        desc="Specifies the interrupt used by the CCC feature. This interrupt must be
        marked as unused in the Ports Implemented (PI) register by the corresponding bit being
        set to '0'. Thus, the CCC interrupt corresponds to the interrupt for an unimplemented
        port on the controller. When a CCC interrupt occurs, the IS.IPS[INT] bit shall be
        asserted to '1'. This field also specifies the interrupt vector used for MSI.";
        sw = r;
    } INT[7:3] = 5'd<%=$NUM_SATA_PORTS+1%>;
    field {
        name="Command Completions";
        desc="Specifies the number of command completions that are
        necessary to cause a CCC interrupt. The HBA has an internal command completion
        counter, hCccComplete.
        
        hCccComplete is incremented by one each time a selected
        port has a command completion. When hCccComplete is equal to the command
        completions value, a CCC interrupt is signaled. The internal command completion
        counter is reset to '0' on the assertion of each CCC interrupt.
        
        A value of '0' for this field
        shall disable CCC interrupts being generated based on the number of commands
        completed, i.e. CCC interrupts are only generated based on the timer in this case.";
    } CC[8] = 8'b1;

    field {
        name="Timeout Value";
        desc="The timeout value is specified in 1 millisecond intervals. The timer
        accuracy shall be within 5%. hCccTimer is loaded with this timeout value. hCccTimer is
        only decremented when commands are outstanding on selected ports, as defined in
        section 11.2. The HBA will signal a CCC interrupt when hCccTimer has decremented to
        '0'. hCccTimer is reset to the timeout value on the assertion of each CCC interrupt. A
        timeout value of '0' is reserved.";
        counter;
        underflow;
        we;
        decrvalue = 0x1;
    } TV[16] = 16'h1;
};

reg CCC_PORTS_REG {

    desc="The command completion coalescing ports register is used to specify the ports that are coalesced as part
    of the CCC feature when CCC_CTL.EN = '1'.";

    field {
        name="Ports";
        desc="This register is bit significant. Each bit corresponds to a particular port,
        where bit 0 corresponds to port 0. If a bit is set to '1', the corresponding port is part of
        the command completion coalescing feature. If a bit is cleared to '0', the port is not part
        of the command completion coalescing feature. Bits set to '1' in this register must also
        have the corresponding bit set to '1' in the Ports Implemented register. An updated
        value for this field shall take effect within one timer increment (1 millisecond).";
    } PRT[32] = 32'h0 ;
};

reg EM_LOC_REG {

    default hw=na;
    default sw=r;

    desc = "The enclosure management location register identifies the location and size of the enclosure
    management message buffer.";

    field {
        name="Buffer Size";
        desc="Specifies the size of the transmit message buffer area in Dwords. If
        both transmit and receive buffers are supported, then the transmit buffer begins at
        ABAR[EM_LOC.OFST*4] and the receive buffer directly follows it. If both transmit and
        receive buffers are supported, both buffers are of the size indicated in the Buffer Size
        field. A value of '0' is invalid.";

    } SZ[16] = 16'h0 ;

    field {
        name="Offset";
        desc="The offset of the message buffer in Dwords from the beginning of the
        ABAR.";
    } OFST[16] = 16'h0;
};

reg EM_CTL_REG {

    desc="This register is used to control and obtain status for the enclosure management interface. The register
    includes information on the attributes of the implementation, enclosure management messages
    supported, the status of the interface, whether any messages are pending, and is used to initiate sending
    messages";

    default hw = na;
    default sw = r;

    field {
        desc="Single Message Buffer (ATTR.SMB): If set to '1', the HBA has one message buffer
        that is shared for messages to transmit and messages received. In this case,
        unsolicited receive messages are not supported and it is software's responsibility to
        manage access to this buffer. If cleared to '0', there are separate receive and transmit
        buffers such that unsolicited messages could be supported.";
    } ATTR_SMB[24:24] = 1'b1;

};


//============================================================================
//
// Vendor Specific Registers:
// Registers at Offset A0h to FFh are reserved for vendor specific capabilities
//
//============================================================================

reg den_sata_config_reg {
    name = "Placeholder register";
    field {
        desc="Foo";
    } bar[32] = 32'h0;
};

regfile PORT_REGFILE {

    desc="the same register mapping. Port 1 starts at 180h, port 2 starts at 200h, port 3 at 280h, etc. The algorithm
    for software to determine the offset is as follows:
    * Port offset = 100h + (PI Asserted Bit Position * 80h)";

    reg CLB_REG {
        desc="Port N Command List Base Address";

        field {
            name="Command List Base Address";
            desc="Indicates the 32-bit base physical address for
            the command list for this port. This base is used when fetching commands to execute.
            The structure pointed to by this address range is 1K-bytes in length. This address must
            be 1K-byte aligned as indicated by bits 09:00 being read only.";
        } CLB[31:20] = 0 ;
    };

    reg CLBU_REG {
        desc="Port N Command List Base Address Upper 32-bits";

        field {
            hw=na;
            sw=r;
            name="FIS Base Address Upper";
            desc="Indicates the upper 32-bits for the received FIS base
            physical address for this port.
            This register shall be read only '0' for HBAs that do not support 64-bit addressing.";
        } CLBU[32] = 32'h0;
    };

    reg FB_REG {
        desc="Port N FIS Base Address";

        field {
            name="FIS Base Address";
            desc="Indicates the 32-bit base physical address for received
            FISes. The structure pointed to by this address range is 256 bytes in length. This
            address must be 256-byte aligned as indicated by bits 07:00 being read only.";
        } FB[31:8] = 24'h0;
    };

    reg FBU_REG {
        desc="Port N FIS Base Address Upper 32-bits";

        field {
            hw=na;
            sw=r;
            name="FIS Base Address Upper";
            desc="Indicates the upper 32-bits for the received FIS base
            physical address for this port.
            This register shall be read only '0' for HBAs that do not support 64-bit addressing.";
        } FBU[32] = 32'h0;
    };

    reg IS_REG {
        default intr;
        default woclr;
        default stickybit;

        field {
            name="Device to Host Register FIS Interrupt";
            desc="A D2H Register FIS has been
            received with the 'I' bit set, and has been copied into system memory.";
            } DHRS = 0;
        field {
            name="PIO Setup FIS Interrupt";
            desc="A PIO Setup FIS has been received with the 'I' bit set,
            it has been copied into system memory, and the data related to that FIS has been
            transferred. This bit shall be set even if the data transfer resulted in an error.";
            } PSS = 0;
        field {
            name="DMA Setup FIS Interrupt";
            desc="A DMA Setup FIS has been received with the 'I' bit
            set and has been copied into system memory.";
        } DSS = 0;

        field {
            name="Set Device Bits Interrupt";
            desc="A Set Device Bits FIS has been received with the
            'I' bit set and has been copied into system memory.";
        } SBDS = 0;

        field {
            name="Unknown FIS Interrupt";
            desc="When set to '1', indicates that an unknown FIS was
            received and has been copied into system memory. This bit is cleared to '0' by
            software clearing the PxSERR.DIAG.F bit to '0'. Note that this bit does not directly
            reflect the PxSERR.DIAG.F bit. PxSERR.DIAG.F is set immediately when an unknown
            FIS is detected, whereas this bit is set when that FIS is posted to memory. Software
            should wait to act on an unknown FIS until this bit is set to '1' or the two bits may
            become out of sync.";
        } UFS = 0;

        field {
            name="Descriptor Processed";
            desc="A PRD with the 'I' bit set has transferred all of its data.
            Refer to section 5.4.2.";
        } DPS = 0;

        field {
            name="Port Connect Change Status";
            desc="1=Change in Current Connect Status. 0=No
            change in Current Connect Status. This bit reflects the state of PxSERR.DIAG.X. This
            bit is only cleared when PxSERR.DIAG.X is cleared.";
        } PCS = 0 ;

        field {
            name="Device Mechanical Presence Status";
            desc="When set, indicates that a mechanical
            presence switch attached to this port has been opened or closed, which may lead to a
            change in the connection state of the device. This bit is only valid if both CAP.SMPS
            and P0CMD.MPSP are set to '1'.";
        } DMPS = 0;

        field {
            name="PhyRdy Change Status";
            desc="When set to '1' indicates the internal PhyRdy signal
            changed state. This bit reflects the state of P0SERR.DIAG.N. To clear this bit,
            software must clear P0SERR.DIAG.N to '0'";
        } PRCS[22:22] = 0;


        field {
            name="Incorrect Port Multiplier Status";
            desc="Indicates that the HBA received a FIS from a
            device whose Port Multiplier field did not match what was expected. The IPMS bit may
            be set during enumeration of devices on a Port Multiplier due to the normal Port
            Multiplier enumeration process. It is recommended that IPMS only be used after
            enumeration is complete on the Port Multiplier.";
        } IPMS = 0;

        field {
            name="Overflow Status";
            desc="Indicates that the HBA received more bytes from a device
            than was specified in the PRD table for the command.";
        } OFS = 0;

        field {
            name="Interface Non-fatal Error Status";
            desc="Indicates that the HBA encountered an error
            on the Serial ATA interface but was able to continue operation. Refer to section 6.1.2.";
        } IONFS[26:26] = 0 ;

        field {
            name="Interface Fatal Error Status";
            desc="Indicates that the HBA encountered an error on
            the Serial ATA interface which caused the transfer to stop. Refer to section 6.1.2.";
        } IFS = 0;

        field {
            name="Host Bus Data Error Status";
            desc="Indicates that the HBA encountered a data error
            (uncorrectable ECC / parity) when reading from or writing to system memory.";
        } HBDS = 0;

        field {
            name="Host Bus Fatal Error Status";
            desc="Indicates that the HBA encountered a host bus
            error that it cannot recover from, such as a bad software pointer. In PCI, such an
            indication would be a target or master abort.";
        } HBFS = 0;

        field {
            name="Task File Error Status";
            desc="This bit is set whenever the status register is updated
            by the device and the error bit (bit 0) is set.";
        } TFES = 0;

        field {
            name="Cold Port Detect Status";
            desc="When set, a device status has changed as detected
            by the cold presence detect logic. This bit can either be set due to a non-connected
            port receiving a device, or a connected port having its device removed. This bit is only
            valid if the port supports cold presence detect as indicated by PxCMD.CPD set to '1'.";
        } CPDS = 0;

    };

    reg IE_REG {
        default hw=r;

        field {
            name="Device to Host Register FIS Interrupt";
            desc="A D2H Register FIS has been
            received with the 'I' bit set, and has been copied into system memory.";
        } DHRE = 0;
        field {
            name="PIO Setup FIS Interrupt";
            desc="A PIO Setup FIS has been received with the 'I' bit set,
            it has been copied into system memory, and the data related to that FIS has been
            transferred. This bit shall be set even if the data transfer resulted in an error.";
        } PSE = 0;
        field {
            name="DMA Setup FIS Interrupt";
            desc="A DMA Setup FIS has been received with the 'I' bit
            set and has been copied into system memory.";
        } DSE = 0;

        field {
            name="Set Device Bits Interrupt";
            desc="A Set Device Bits FIS has been received with the
            'I' bit set and has been copied into system memory.";
        } SBDE = 0;

        field {
            name="Unknown FIS Interrupt";
            desc="When set to '1', indicates that an unknown FIS was
            received and has been copied into system memory. This bit is cleared to '0' by
            software clearing the PxSERR.DIAG.F bit to '0'. Note that this bit does not directly
            reflect the PxSERR.DIAG.F bit. PxSERR.DIAG.F is set immediately when an unknown
            FIS is detected, whereas this bit is set when that FIS is posted to memory. Software
            should wait to act on an unknown FIS until this bit is set to '1' or the two bits may
            become out of sync.";
        } UFS = 0;

        field {
            name="Descriptor Processed";
            desc="A PRD with the 'I' bit set has transferred all of its data.
            Refer to section 5.4.2.";
        } DPE = 0;

        field {
            name="Port Connect Change Status";
            desc="1=Change in Current Connect Status. 0=No
            change in Current Connect Status. This bit reflects the state of PxSERR.DIAG.X. This
            bit is only cleared when PxSERR.DIAG.X is cleared.";
        } PCE = 0 ;

        field {
            name="Device Mechanical Presence Status";
            desc="When set, indicates that a mechanical
            presence switch attached to this port has been opened or closed, which may lead to a
            change in the connection state of the device. This bit is only valid if both CAP.SMPS
            and P0CMD.MPSP are set to '1'.";
        } DMPE = 0;

        field {
            name="PhyRdy Change Status";
            desc="When set to '1' indicates the internal PhyRdy signal
            changed state. This bit reflects the state of P0SERR.DIAG.N. To clear this bit,
            software must clear P0SERR.DIAG.N to '0'";
        } PRCE[22:22] = 0;


        field {
            name="Incorrect Port Multiplier Status";
            desc="Indicates that the HBA received a FIS from a
            device whose Port Multiplier field did not match what was expected. The IPMS bit may
            be set during enumeration of devices on a Port Multiplier due to the normal Port
            Multiplier enumeration process. It is recommended that IPMS only be used after
            enumeration is complete on the Port Multiplier.";
        } IPME = 0;

        field {
            name="Overflow Status";
            desc="Indicates that the HBA received more bytes from a device
            than was specified in the PRD table for the command.";
        } OFE = 0;

        field {
            name="Interface Non-fatal Error Status";
            desc="Indicates that the HBA encountered an error
            on the Serial ATA interface but was able to continue operation. Refer to section 6.1.2.";
        } IONFE[26:26] = 0 ;

        field {
            name="Interface Fatal Error Status";
            desc="Indicates that the HBA encountered an error on
            the Serial ATA interface which caused the transfer to stop. Refer to section 6.1.2.";
        } IFE = 0;

        field {
            name="Host Bus Data Error Status";
            desc="Indicates that the HBA encountered a data error
            (uncorrectable ECC / parity) when reading from or writing to system memory.";
        } HBDE = 0;

        field {
            name="Host Bus Fatal Error Status";
            desc="Indicates that the HBA encountered a host bus
            error that it cannot recover from, such as a bad software pointer. In PCI, such an
            indication would be a target or master abort.";
        } HBFE = 0;

        field {
            name="Task File Error Status";
            desc="This bit is set whenever the status register is updated
            by the device and the error bit (bit 0) is set.";
        } TFEE = 0;

        field {
            name="Cold Port Detect Status";
            desc="When set, a device status has changed as detected
            by the cold presence detect logic. This bit can either be set due to a non-connected
            port receiving a device, or a connected port having its device removed. This bit is only
            valid if the port supports cold presence detect as indicated by PxCMD.CPD set to '1'.";
        } CPDE = 0;
    };


    enum ICC_ENUM {
        Slumber = 4'h6 {
            desc = "This shall cause the HBA to request a transition of the
            interface to the Slumber state. The SATA device may reject the
            request and the interface shall remain in its current state.
            5h - 3h Reserved";
        };

        PARTIAL = 4'h2 {
            desc = "This shall cause the HBA to request a transition of the
            interface to the Partial state. The SATA device may reject the
            request and the interface shall remain in its current state.";
        };

        ACTIVE  = 4'h1 {
            desc = "This shall cause the HBA to request a transition of the
            interface into the active state.";
        };

        NO_OP_IDLE = 4'h0 {
            desc ="When software reads this value, it indicates the HBA is
            ready to accept a new interface control command, although the
            transition to the previously selected state may not yet have occurred.";
        };
    };

    reg ICC_REG {
        field {
            name="Start";
            desc="When set, the HBA may process the command list. When cleared, the
            HBA may not process the command list. Whenever this bit is changed from a '0' to a
            '1', the HBA starts processing the command list at entry '0'. Whenever this bit is
            changed from a '1' to a '0', the PxCI register is cleared by the HBA upon the HBA
            putting the controller into an idle state. This bit shall only be set to '1' by software after
            PxCMD.FRE has been set to '1'. Refer to section 10.3.1 for important restrictions on
            when ST can be set to '1'. ";
        } ST = 0;

        field {
            name="Spin-Up Device";
            desc="This bit is read/write for HBAs that support staggered spin-up
            via CAP.SSS. This bit is read only '1' for HBAs that do not support staggered spin-up.
            On an edge detect from '0' to '1', the HBA shall start a COMRESET initializatoin
            sequence to the device. Clearing this bit to '0' does not cause any OOB signal to be
            sent on the interface. When this bit is cleared to '0' and PxSCTL.DET=0h, the HBA will
            enter listen mode as detailed in section 10.9.1.";
        } SUD = 0 ;

        field {
            name="Power On Device";
            desc="This bit is read/write for HBAs that support cold presence
            detection on this port as indicated by PxCMD.CPD set to '1'. This bit is read only '1' for
            HBAs that do not support cold presence detect. When set, the HBA sets the state of a
            pin on the HBA to '1' so that it may be used to provide power to a cold-presence
            detectable port.";
        } POD = 0 ;

        field {
            name="Command List Override";
            desc="Setting this bit to '1' causes PxTFD.STS.BSY and
            PxTFD.STS.DRQ to be cleared to '0'. This allows a software reset to be transmitted to
            the device regardless of whether the BSY and DRQ bits are still set in the PxTFD.STS
            register. The HBA sets this bit to '0' when PxTFD.STS.BSY and PxTFD.STS.DRQ
            have been cleared to '0'. A write to this register with a value of '0' shall have no effect.
            This bit shall only be set to '1' immediately prior to setting the PxCMD.ST bit to '1' from
            a previous value of '0'. Setting this bit to '1' at any other time is not supported and will
            result in indeterminate behavior. Software must wait for CLO to be cleared to '0' before
            setting PxCMD.ST to '1'.";
        } CLO = 0 ;


        field {
            name="FIS Receive Enable";
            desc="When set, the HBA may post received FISes into the FIS
            receive area pointed to by PxFB (and for 64-bit HBAs, PxFBU). When cleared,
            received FISes are not accepted by the HBA, except for the first D2H register FIS after
            the initialization sequence, and no FISes are posted to the FIS receive area.
            System software must not set this bit until PxFB (PxFBU) have been programmed with
            a valid pointer to the FIS receive area, and if software wishes to move the base, this
            must first be cleared, and software must wait for the FR bit in this register to be cle
            Refer to section 10.3.2 for important restrictions on when FRE can be set and cleared.";
        } FRE = 0;

        field {
            name="Current Command Slot";
            desc="This field is valid when P0CMD.ST is set to '1' and
            shall be set to the command slot value of the command that is currently being issued by
            the HBA. When P0CMD.ST transitions from '1' to '0', this field shall be reset to '0'.
            After P0CMD.ST transitions from '0' to '1', the highest priority slot to issue from next is
            command slot 0. After the first command has been issued, the highest priority slot to
            issue from next is P0CMD.CCS + 1. For example, after the HBA has issued its first
            command, if CCS = 0h and P0CI is set to 3h, the next command that will be issued is
            from command slot 1.";
        } CCS[12:8] = 0;

        field {
            name="Mechanical Presence Switch State";
            desc="The MPSS bit reports the state of a
            mechanical presence switch attached to this port. If CAP.SMPS is set to '1' and the
            mechanical presence switch is closed then this bit is cleared to '0'. If CAP.SMPS is set
            to '1' and the mechanical presence switch is open then this bit is set to '1'. If
            CAP.SMPS is set to '0' then this bit is cleared to '0'. Software should only use this bit if
            both CAP.SMPS and P0CMD.MPSP are set to '1'.";
        } MPSS = 0;

        field {
            name="FIS Receive Running";
            desc="When set, the FIS Receive DMA engine for the port is
            running. See section 10.3.2 for details on when this bit is set and cleared by the HBA.";
        } FR = 0 ;

        field {
            name="Command List Running";
            desc="When this bit is set, the command list DMA engine for
            the port is running. See the AHCI state machine in section 5.3.2 for details on when
            this bit is set and cleared by the HBA.";
        } CR = 0;

        field {
            name="Cold Presence State";
            desc="The CPS bit reports whether a device is currently
            detected on this port via cold presence detection. If CPS is set to '1', then the HBA
            detects via cold presence that a device is attached to this port. If CPS is cleared to '0' ,
            then the HBA detects via cold presence that there is no device attached to this port.";
        } CPS = 0;

        field {
            name="Port Multiplier Attached";
            desc="This bit is read/write for HBAs that support a Port
            Multiplier (CAP.SPM = '1'). This bit is read-only for HBAs that do not support a port
            Multiplier (CAP.SPM = '0'). When set to '1' by software, a Port Multiplier is attached to
            the HBA for this port. When cleared to '0' by software, a Port Multiplier is not attached
            to the HBA for this port. Software is responsible for detecting whether a Port Multiplier
            is present; hardware does not auto-detect the presence of a Port Multiplier.";
        } PMA = 0;

        field {
            sw=r;
            name="Hot Plug Capable Port";
            desc="When set to '1', indicates that this port's signal and
            power connectors are externally accessible via a joint signal and power connector for
            blindmate device hot plug. When cleared to '0', indicates that this port's signal and
            power connectors are not externally accessible via a joint signal and power connector.";
        } HPCP = 0;

        field {
            name="Mechanical Presence Switch Attached to Port";
            desc="If set to '1', the platform
            supports an mechanical presence switch attached to this port. If cleared to '0', the
            platform does not support a mechanical presence switch attached to this port. When
            this bit is set to '1', P0CMD.HPCP should also be set to '1'.";
        } MPSP = 0;

        field {
            sw = r;
            name="Cold Presence Detection";
            desc="If set to '1', the platform supports cold presence
            detection on this port. If cleared to '0', the platform does not support cold presence
            detection on this port. When this bit is set to '1', P0CMD.HPCP should also be set to
            '1'.";
        } CPD = 0 ;

        field {
            name="External SATA Port";
            desc="When set to '1', indicates that this port's signal connector
            is externally accessible on a signal only connector. When set to '1', CAP.SXS shall be
            set to '1'. When cleared to '0', indicates that this port's signal connector is not externally
            accessible on a signal only connector. ESP is mutually exclusive with the HPCP bit in
            this register.";
        } ESP = 0;

        field {
            name="Device is ATAPI";
            desc="When set to '1', the connected device is an ATAPI device.
            This bit is used by the HBA to control whether or not to generate the desktop LED when
            commands are active. See section 10.10 for details on the activity LED.";
        } ATAPI[24:24] = 0;

        field {
            name="Drive LED on ATAPI Enable";
            desc="When set to '1', the HBA shall drive the LED
            pin active for commands regardless of the state of P0CMD.ATAPI. When cleared, the
            HBA shall only drive the LED pin active for commands if P0CMD.ATAPI set to '0'. See
            section 10.10 for details on the activity LED.";
        } DLAE = 0;

        field {
            name="Aggressive Link Power Management Enable";
            desc="When set to '1', the HBA shall
            aggressively enter a lower link power state (Partial or Slumber) based upon the setting
            of the ASP bit. Software shall only set this bit to '1' if CAP.SALP is set to '1' if
            CAP.SALP is cleared to '0' software shall treat this bit as reserved. See section 8.3.1.3
            for details.";
        } ALPE = 0;

        field {
            desc="Aggressive Slumber / Partial (ASP): When set to '1', and ALPE is set, the HBA shall
            aggressively enter the Slumber state when it clears the PxCI register and the PxSACT
            register is cleared or when it clears the PxSACT register and PxCI is cleared. When
            cleared, and ALPE is set, the HBA shall aggressively enter the Partial state when it
            clears the PxCI register and the PxSACT register is cleared or when it clears the
            PxSACT register and PxCI is cleared. If CAP.SALP is cleared to '0' software shall treat
            this bit as reserved. See section 8.3.1.3 for details.";
        } ASP = 1'b0;


        field {
            encode = ICC_ENUM;
            name="Interface Communication Control";
            desc="This field is used to control power
            management states of the interface. If the Link layer is currently in the L_IDLE state,
            writes to this field shall cause the HBA to initiate a transition to the interface power
            management state requested. If the Link layer is not currently in the L_IDLE state,
            writes to this field shall have no effect.

            When system software writes a non-reserved value other than No-Op (0h), the HBA
            shall perform the action and update this field back to Idle (0h).
            If software writes to this field to change the state to a state the link is already in (i.e.
            interface is in the active state and a request is made to go to the active state), the HBA
            shall take no action and return this field to Idle. If the interface is in a low power state
            and software wants to transition to a different low power state, software must first bring
            the link to active and then initiate the transition to the desired low power state.";
        } ICC[4] = 4'h0;
    };

    reg TFD_REG {
        desc = "This is a 32-bit register that copies specific fields of the task file when FISes are received.
        The FISes that contain this information are:
        
        * D2H Register FIS
        * PIO Setup FIS
        * Set Device Bits FIS (BSY and DRQ are not updated with this FIS)
        ";

        field {
            sw=r;
            name="Error";
            desc="Contains the latest copy of the task file error register.";
        } ERR[8] = 8'b0;

        field {
            name="Status";
            desc="Contains the latest copy of the task file status register. Fields of note in
            this register that affect AHCI hardware operation are:
            
            * [7] BSY Indicates the interface is busy
            * [6:4] cs Command specific
            * [3] DRQ Indicates a data transfer is requested
            * [2:1] cs Command specific
            * [0] ERR Indicates an error during the transfer.
            
            The HBA shall update the entire 8-bit field, not just the bits noted above. ";
        } STS[8]=8'h7f;

    }; // End of Reg: TFD_REG

    reg SIGNATURE {

        desc = "This is a 32-bit register which contains the initial signature of an attached device when the first D2H
        Register FIS is received from that device. It is updated once after a reset sequence.
        Signature (SIG): Contains the signature received from a device on the first
        D2H Register FIS. The bit order is as follows: ";

        default sw = r;

        field {
            name="Sector Count Register";
        } SECTOR_COUNT = 8'hff;
        field {
            name="LBA Low Register";
        } LBAL[8] = 8'hff;
        field {
            name="LBA Mid Register";
        } LBAM[8] = 8'hff;
        field {
            name="LBA High Register";
        } LBAH[8] = 8'hff;

    }; // End of Reg: SIGNATURE


    reg SCR0_SSTATUS {
        desc = "This 32-bit register conveys the current state of the interface and host. The HBA updates it continuously
        and asynchronously. When the HBA transmits a COMRESET to the device, this register is updated to its
        reset values.";

        default sw = r;

        field {
            name="Device Detection";
            desc="Indicates the interface device detection and Phy state.";
        } DET = 0; // End of field: DET

        field {
            name="Current Interface Speed";
            desc="Indicates the negotiated interface communication
            speed.";
        } SPD = 0 ;

        field {
            name="Interface Power Management";
            desc="Indicates the current interface state:";
        } IPM = 0 ;

    };

    CLB_REG                      CLB;    // Command List Base Address
    CLBU_REG                     CLBU;   // Command List Base Addres Upper (NA)
    FB_REG                       FB;     // FIS Base Address
    FBU_REG                      FBU;    // FIS Base Address Uppper
    IS_REG                       IS;
    IE_REG                       IE;
    ICC_REG                      ICC;
    TFD_REG                      TFD;
};


addrmap den_sata_ahci_map {

    name = "Denali SATA Core Register Map";
    desc = "This Map contains the complete register set for
    Denali SATA Core (Host Controller).  There are variables
    here to control the addressing for num_ports > 1";


    // Generic Host Control Registers
    // There is only one set of these regardless of the numer of SATA Ports
    //
    HBA_CAP_REG        HBA_CAP @0x0000;                      // HBA Capabilities Register
    GHC_REG            GHC;                                  // General Host Controller Register
    IS_REG             IS;                                   // Interupt Status Register
    PI_REG             PI;                                   // Port Implimented Register
    VS_REG             VS;                                   // AHCI Version Number Register
    CCC_CTL_REG        CCC_CTL;                              // Command Coalescing Control Register
    CCC_PORTS_REG      CCC_PORTS;                            // Command Coaslescing Port Control Register
    EM_LOC_REG         EM_LOC;                               // Enclosure Managment Location
    EM_CTL_REG         EM_CTL;                               // Enclosure Managment Control

    // Generic Host Control Registers
    // There is only one set of these regardless of the numer of SATA Ports
    //
    den_sata_config_reg foo   @0xA0;                         // Place Holder for Denali Regs

    // Port Specific Control Registers
    // There is one set of these for each sata port on the host controller.
    //
    external PORT_REGFILE       PORT[<%=$NUM_SATA_PORTS%>]   @0x100 += 0x80;  // Instance all the Port Specific Regs

};

